<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Mobile Spirit Level ‚Äî Pro Civil Auditor</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#10b981; --muted:#9aa4b2;
  }
  html,body{height:100%; margin:0; font-family:Inter,Segoe UI,system-ui,Arial; background:linear-gradient(180deg,#071023 0%, #0b1530 100%); color:#e6eef6;}
  .wrap{min-height:100%; display:flex; align-items:center; justify-content:center; padding:20px; box-sizing:border-box;}
  .card{width:100%; max-width:760px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:16px; padding:18px; box-shadow:0 6px 30px rgba(2,6,23,0.6);}
  h1{margin:0 0 10px; font-size:20px; display:flex; align-items:center; gap:10px;}
  p.lead{margin:0 0 12px; color:var(--muted); font-size:13px;}
  .top-row{display:flex; gap:10px; align-items:center; margin-bottom:12px;}
  .btn{background:#0f1724;border:1px solid rgba(255,255,255,0.04); color:#dbeafe; padding:10px 12px; border-radius:10px; font-weight:600; font-size:14px; cursor:pointer;}
  .btn.primary{background:linear-gradient(90deg,#06b6d4,#3b82f6); color:#021024; border:none;}
  .btn.warn{background:#f59e0b; color:#051019;}
  .controls{display:flex; gap:8px; flex-wrap:wrap;}
  .level-area{display:flex; gap:14px; align-items:center; flex-wrap:wrap;}
  .dial{
    width:260px; height:260px; border-radius:50%; background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.02), transparent 15%), linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    display:flex; align-items:center; justify-content:center; position:relative; box-shadow: inset 0 10px 30px rgba(2,6,23,0.6);
    border: 2px solid rgba(255,255,255,0.03);
  }
  .dial .grid{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;}
  .ring{width:92%; height:92%; border-radius:50%; border:1px dashed rgba(255,255,255,0.04); position:absolute; top:4%; left:4%;}
  .bubble{
    width:48px; height:48px; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, #ffffff, #cceefc 45%, rgba(200,230,255,0.15) 70% );
    box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 6px 10px rgba(255,255,255,0.6);
    transform: translate(-50%,-50%);
    position:absolute; left:50%; top:50%;
    transition: transform 0.04s linear;
    border: 2px solid rgba(0,0,0,0.08);
  }
  .center-hair{position:absolute; width:2px; height:100%; left:50%; top:0; background:linear-gradient(180deg, rgba(255,255,255,0.05), transparent 40%);}
  .center-hair.horiz{width:100%; height:2px; left:0; top:50%;}
  .readouts{min-width:180px; color:var(--muted); display:flex; flex-direction:column; gap:8px; font-size:13px;}
  .status{display:flex; gap:8px; align-items:center;}
  .dot{width:12px; height:12px; border-radius:50%; background:#ef4444; box-shadow:0 0 8px rgba(239,68,68,0.2);}
  .dot.on{background:var(--accent); box-shadow:0 0 12px rgba(16,185,129,0.25);}
  .angle{font-size:20px; color:#e6f7f2; font-weight:700;}
  .small{font-size:12px; color:var(--muted);}
  .footer{margin-top:12px; display:flex; align-items:center; gap:8px; justify-content:space-between;}
  .hint{font-size:12px; color:var(--muted);}
  .calib{display:flex; gap:8px; align-items:center;}
  @media(max-width:620px){
    .dial{width:220px; height:220px;}
    .readouts{min-width:140px;}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="application" aria-label="Mobile spirit level">
    <h1>üìè Digital Spirit Level</h1>
    <p class="lead">Use your phone like a bubble level. Hold flat and rotate to check pitch and roll. Works best in vertical/horizontal plane.</p>

    <div class="top-row controls">
      <button id="requestPerm" class="btn primary">Enable Sensors</button>
      <button id="calibrate" class="btn">Calibrate</button>
      <button id="resetCal" class="btn">Reset Calibration</button>
      <label class="btn" id="toleranceLabel">Tolerance: <input id="tolerance" type="range" min="0.2" max="5" value="1" step="0.1" style="vertical-align:middle;margin-left:8px;"></label>
    </div>

    <div class="level-area" style="margin-top:14px;">
      <div class="dial" id="dial" aria-hidden="true">
        <div class="ring"></div>
        <div class="center-hair" aria-hidden="true"></div>
        <div class="center-hair horiz" aria-hidden="true"></div>
        <div class="bubble" id="bubble" role="img" aria-label="bubble"></div>
      </div>

      <div class="readouts" aria-live="polite">
        <div><span class="small">Pitch (front/back)</span><div class="angle" id="pitch">0¬∞</div></div>
        <div><span class="small">Roll (left/right)</span><div class="angle" id="roll">0¬∞</div></div>
        <div class="status small"><span class="dot" id="levelDot" title="level indicator"></span><span id="levelText">Not level</span></div>
        <div class="small">Calib offset: <span id="calVal">0¬∞,0¬∞</span></div>
        <div class="small">Sensor: <span id="sensorType">unknown</span></div>
      </div>
    </div>

    <div class="footer">
      <div class="hint">Tip: For best accuracy, keep phone back clean and flat. Use calibration for cases with cases/bumps.</div>
      <div class="calib small">vibrate when level <input type="checkbox" id="vib" checked style="margin-left:8px;"></div>
    </div>
  </div>
</div>

<script>
(() => {
  // Elements
  const bubble = document.getElementById('bubble');
  const pitchEl = document.getElementById('pitch');
  const rollEl = document.getElementById('roll');
  const levelDot = document.getElementById('levelDot');
  const levelText = document.getElementById('levelText');
  const calBtn = document.getElementById('calibrate');
  const resetCalBtn = document.getElementById('resetCal');
  const calVal = document.getElementById('calVal');
  const permBtn = document.getElementById('requestPerm');
  const tolInput = document.getElementById('tolerance');
  const sensorTypeEl = document.getElementById('sensorType');
  const vibCheck = document.getElementById('vib');

  // State
  let calib = {pitch:0, roll:0};
  let tolerance = parseFloat(tolInput.value) || 1.0; // degrees
  let lastVib = 0;
  const vibCooldownMs = 1000;

  // map tilt degrees to bubble translation in px relative to dial radius
  function tiltToPos(rollDeg, pitchDeg){
    // dial size read from DOM:
    const dial = document.getElementById('dial');
    const rect = dial.getBoundingClientRect();
    const radius = Math.min(rect.width, rect.height)/2 * 0.8; // keep bubble inside ring
    // clamp degrees to reasonable maximum for mapping
    const maxDeg = 30;
    const x = (rollDeg / maxDeg) * radius;
    const y = -(pitchDeg / maxDeg) * radius; // pitch positive -> bubble moves up (invert)
    // clamp to circle
    const d = Math.sqrt(x*x + y*y);
    if(d > radius) {
      const scale = radius / d;
      return {x: x*scale, y: y*scale};
    }
    return {x,y};
  }

  // set bubble position
  function updateBubble(roll, pitch){
    const pos = tiltToPos(roll, pitch);
    bubble.style.transform = `translate(calc(-50% + ${pos.x}px), calc(-50% + ${pos.y}px))`;
  }

  // set readouts + level indicator
  function updateReadouts(roll, pitch){
    rollEl.textContent = `${roll.toFixed(1)}¬∞`;
    pitchEl.textContent = `${pitch.toFixed(1)}¬∞`;
    const level = Math.abs(roll) <= tolerance && Math.abs(pitch) <= tolerance;
    if(level){
      levelDot.classList.add('on');
      levelText.textContent = 'Level';
      if(vibCheck.checked && navigator.vibrate && Date.now() - lastVib > vibCooldownMs){
        navigator.vibrate(80);
        lastVib = Date.now();
      }
    } else {
      levelDot.classList.remove('on');
      levelText.textContent = 'Not level';
    }
  }

  // calibration
  calBtn.addEventListener('click', () => {
    // uses last known values stored in lastAngles
    if(window.lastAngles){
      calib.pitch = window.lastAngles.pitch;
      calib.roll = window.lastAngles.roll;
      calVal.textContent = `${calib.pitch.toFixed(1)}¬∞, ${calib.roll.toFixed(1)}¬∞`;
    } else {
      alert('Move phone to the desired reference position and then tap Calibrate again.');
    }
  });

  resetCalBtn.addEventListener('click', () => {
    calib = {pitch:0, roll:0};
    calVal.textContent = `0¬∞,0¬∞`;
  });

  tolInput.addEventListener('input', ()=> {
    tolerance = parseFloat(tolInput.value);
  });

  // helper to clamp angle to [-180,180]
  function normalizeAngle(a){
    let v = a;
    while(v > 180) v -= 360;
    while(v <= -180) v += 360;
    return v;
  }

  // handle DeviceOrientationEvent (alpha/beta/gamma)
  function handleOrientation(event){
    // beta: -180..180 front-back (pitch)
    // gamma: -90..90 left-right (roll)
    let pitch = event.beta ?? 0;   // front/back
    let roll  = event.gamma ?? 0;  // left/right

    // make sure angles normalized
    pitch = normalizeAngle(pitch);
    roll = normalizeAngle(roll);

    // apply calibration offsets (subtract so calibrated position becomes zero)
    pitch = pitch - calib.pitch;
    roll = roll - calib.roll;

    // clamp to plausible range for display
    if(pitch > 180) pitch -= 360;
    if(roll > 180) roll -= 360;

    // save last
    window.lastAngles = {pitch, roll};

    updateBubble(roll, pitch);
    updateReadouts(roll, pitch);
    sensorTypeEl.textContent = 'DeviceOrientation';
  }

  // fallback: DeviceMotion -> compute gravity vector if orientation not available
  function handleMotion(e){
    const a = e.accelerationIncludingGravity;
    if(!a) return;
    // approximate pitch/roll from gravity vector
    const gx = a.x; const gy = a.y; const gz = a.z;
    // formulas: pitch = atan2(-gx, sqrt(gy^2+gz^2)) ; roll = atan2(gy, gz)
    const pitch = Math.atan2(-gx, Math.sqrt(gy*gy + gz*gz)) * 180/Math.PI;
    const roll  = Math.atan2(gy, gz) * 180/Math.PI;

    window.lastAngles = {pitch, roll};
    const p = pitch - calib.pitch;
    const r = roll - calib.roll;
    updateBubble(r, p);
    updateReadouts(r, p);
    sensorTypeEl.textContent = 'DeviceMotion';
  }

  // request permission on iOS if needed
  async function enableSensors(){
    // modern iOS requires explicit permission
    if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      try {
        const resp = await DeviceOrientationEvent.requestPermission();
        if(resp === 'granted'){
          window.addEventListener('deviceorientation', handleOrientation, true);
          sensorTypeEl.textContent = 'DeviceOrientation (granted)';
        } else {
          alert('Permission denied for DeviceOrientation. Falling back to motion if available.');
          window.addEventListener('devicemotion', handleMotion, true);
        }
      } catch(err){
        console.warn('Permission error',err);
        alert('Unable to get permission for DeviceOrientation.');
      }
    } else {
      // non-iOS or older: just add listeners
      if('ondeviceorientation' in window){
        window.addEventListener('deviceorientation', handleOrientation, true);
        sensorTypeEl.textContent = 'DeviceOrientation';
      } else if('ondevicemotion' in window){
        window.addEventListener('devicemotion', handleMotion, true);
        sensorTypeEl.textContent = 'DeviceMotion';
      } else {
        alert('No motion/orientation sensors available in this browser.');
      }
    }
  }

  permBtn.addEventListener('click', enableSensors);

  // auto-enable if already allowed (best-effort)
  if('ondeviceorientation' in window && typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission !== 'function'){
    // non-iOS, just add
    window.addEventListener('deviceorientation', handleOrientation, true);
    sensorTypeEl.textContent = 'DeviceOrientation';
  } else if('ondevicemotion' in window && typeof DeviceOrientationEvent === 'undefined'){
    window.addEventListener('devicemotion', handleMotion, true);
    sensorTypeEl.textContent = 'DeviceMotion';
  }

  // accessibility: allow touch to center bubble quickly (reset calibration to current)
  document.getElementById('dial').addEventListener('dblclick', ()=>{
    if(window.lastAngles){
      calib.pitch = window.lastAngles.pitch;
      calib.roll = window.lastAngles.roll;
      calVal.textContent = `${calib.pitch.toFixed(1)}¬∞, ${calib.roll.toFixed(1)}¬∞`;
      alert('Calibrated to current position (double-tap).');
    }
  });

  // hint for iOS permissions UX:
  // If loaded on iOS Safari, user must tap "Enable Sensors" and then "Allow" in system prompt.
})();
</script>
</body>
</html>
